---
typora-copy-images-to: paper_figure
---
## Inter-Flow Consistency: Novel SDN Update Abstraction for Supporting Inter-Flow Constraints

@CNS 2015 @Inter-Flow consistent update in SDN
[TOC]

## Summary
***Motivation of this paper***:

  网络更新综述给出的两个更新抽象，单包一致性和单流一致性不足以满足网络中很多流的安全性和可靠性需求。他们都不考虑流之间的关系，无法保留流之间的某些关系。所以需要提出一种新的流之间的抽象更新处理策略。

per-packet consistency：网络中的数据包要么是被旧配置处理，要么是被新配置处理，不会混合。

per-flow consistency：网络中的流要么是被旧配置处理，要么是被新配置处理，不会混合。

适用条件：1.版本隔离流的需求很小；2.转发到控制器的流量是合适的，更新时间很短。


***Method***

**spatial Isolation**

两条流不允许通过同一个link。空间隔离表示为了安全性或可靠性原因，在更新之前，期间和之后不允许某些流共享链路或交换机的要求。

举个例子，有一条携带了控制信息的流经过某一条链路，而那条链路同时又携带了工程或调试流量，为了安全和可靠性，不希望控制信息的流量出现延迟或丢包，就会被工程流量影响。前提假设更新前后都是满足需求的，但是在更新期间保证该需求至今没有解决方案。

**Version Isolation**

版本隔离意味着来自不同相关流的数据包在通过网络时不能由两个不同版本的流规则处理。也就是说需要满足所有数据包要么是被更新前的旧配置处理要么是被更新后的新配置处理，而不能混合。



  两阶段更新改进策略：选择需要进行版本隔离的流集合中的一条流，其余的发送到控制器存储下来。然后更新所选流的规则，此期间其他流的数据包被发送到控制器。选在版本隔离集中的另一条流进行更新，控制器传输缓存的包进入网络。重复上面步骤直到版本隔离集为空，不在此集合中的其他流可以被并行更新。

```
算法1  两阶段更新
输入：F，版本隔离的流集合
f0←一条流
F←F-f0
转发所有F的流量到控制器
更新f0的规则
for each f in F do
	更新f的规则
	停止转发f的流量到控制器
	控制器将缓存的流量送回网络
end for
```

****

调度原则是，基于依赖图中满足两个条件的结点，在同一阶段更新：

- 没有祖先结点
- 满足链路资源

而对于同一阶段的结点调度(round)，使用贪心算法原则。基于Dionysus的关键路径方法，分配给每个操作结点权重为1，资源、互斥和路径结点为0，对于同一round的操作结点，按照CPL对结点降序排列，贪心选择CPL最大的结点进行调度。

$$
CPL_i = w_i + \max\limits_{j \in children(i)} CPL_j
$$

```
算法2 调度更新（F, N0, N1, C）
输入：F，将被更新转发规则的流
	 N0，F的初始网络状态（路径的链路和容量）
	 N1，F的新网络状态
	 C，更新约束（空间或版本隔离）
G ← GenerateGraph(F, N0, N1)
G ← ReviseGraph(G, C)
计算G中每个结点的CPL
根据CPL对所有结点降序排序，得到一个有序列L
while G不为空 do
	for 每个属于L操作结点Oi do
		if Oi没有祖先结点且能获得需要的资源 then
			调度Oi
		end if
	end for
	删除已经调度的操作结点和对应路径结点的边
	删除没有边连接的资源结点和互斥结点
	更新可获取的资源节点
	等待一段时间间隔，所有已调度操作完成。继续判断图G是否为空，循环以上。
end while

```

依赖图的生成算法如下，首先生成图中的资源结点，其次比较每一条流的新旧路径，可以计算出更新操作。然后增加路径-资源关系和结点-资源关系的边。CreateEdges((s1, d1),(s2, d2),...)函数用来创建从si到di的边。floodgate操作是将转发数据包从旧到新路径的第一个更新操作。

```
算法3 GenerateGraph(F, N0, N1)
G初始化为空
for each link，l in N0和N1 do
	创建资源结点v，表示l和剩余容量
end for
for each f in F do
	p0←N0中的旧路径f
	创建从p0到每个相关资源结点的边
	p1←N1中的新路径f
	创建从每个资源结点到新路径的边
	Of←p0和p1的floodgate操作，即新旧路径的入口交换机操作
	O0 ← 移除p0的操作集
	O1 ← 增加p1的操作集
	CreateEdges((Of, p0), (p1, Of), (p0, O0), (O1, p1))  
end for
return G
```

修订图的算法如下

```
算法4 ReviseGraph(G, C)
输入:G,C
for each 约束c in C do
	if c 是空间隔离 then
		for 被流共享的，被c约束的资源r do
			创建一个互斥结点rm
			创建rm和相应路径结点的边
		end for
	else if c是版本隔离 then
		F ← 被c约束的流
		f0 ← F中的一条流
		F ← F - f0
		创建一个操作结点Om,代表转发F到控制器
		创建从Om到所有F中流的父亲结点的边
		for each f in F do
			p1 ← f的新路径
			翻转p1和流f的floodgate的边方向
			创建一个操作结点Od，表示停止转发f到控制器
			创建一个操作结点Oi,表示控制器注入缓存的f流量到网络
			CreateEdges((p1, Od), (f0, Od), (Od, Oe))//这句算法伪代码那我怀疑写错了符号
		end for
	end if
end for
return G
			
```

***Implementation and Evaluation***:

- mininet, 3层树形拓扑， 1个核心交换机5个汇聚交换机，每个汇聚交换机连接5个ToR交换机。连接到ToR交换机的主机数量从2到20不等。链路带宽设置为1Gbps.
- RYU层实现系统原型，基于最短路径路由应用。
- 1000+ python

定义具有相同发送IP的数据包为一条流，每个实验分为两个阶段。

- 第一阶段，生成网络状态，包含随机生成的端到端对的流。在端到端对中，一个主机连续发送UDP数据包到目的端。然后最短路径路由应用会计算并安装每条流的规则到数据平面。同时，实现的系统模型会记录每条流的路径信息，流率设置为1Mbps。
- 第二阶段，生成一个新的网络状态。蛮力搜索：对流A和B，如果新旧路径各自都是空间隔离的，但在A的旧路径和B的新路径有重叠，我们旧分配一个空间隔离条件给A和B。

实验结果展示了随着主机数量增加，隔离约束的数量和操作增加数量的变化；也展示了随着主机数量增加，对应的更新总时间、生成依赖图时间和调度更新时间的变化趋势。

## Strength (Contributions of the paper)

## Weakness (Limitations of the paper)

- 假设前提是总是存在一个更新操作的正确的顺序，满足带宽、空间隔离和版本隔离。没有考虑解决流之间可能存在死锁和大象流的链路拥塞问题。
- 算法实现方面只实现了空间隔离，没有实现版本隔离的实际应用。

## Future Works

## Related to my work

- 依赖图的生成算法可以用到我的实现
- 可以参考实验评估的步骤和数据形式